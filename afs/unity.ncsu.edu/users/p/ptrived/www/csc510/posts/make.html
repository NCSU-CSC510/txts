<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Make</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../img/posty.css" type="text/css" />
</head>
<body>
<b><font size="+3">Software Engineering, cs510, Spring 2015</font></b>
<div id="navcontainer">
<img width=300 align=right src="http://www.cvm.ncsu.edu/ess/emd/cvm_logos/NCSU%20LOGO.jpg">
<ul id="navlist">
<li><a href="se.html">Home</a></li>
<li><a href="syllabus.html">Syllabus</a></li>
<li><a href="lectures.html">Lectures</a></li>
<li><a href="project.html">Project</a></li>
<li><a href="homeworks.html">Homeworks</a></li>
</ul>
</div>
<hr>
<em>Department of Computer Science, College of Engineering</em>
<div id="header">
<h1 class="title">Make</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#what-is-make">What is Make?</a><ul>
<li><a href="#capabilities-of-make">Capabilities of Make</a></li>
</ul></li>
<li><a href="#more-about-make">More about MAKE</a><ul>
<li><a href="#aside-parallel-makes">Aside: Parallel Makes</a></li>
<li><a href="#configuring-make">Configuring Make</a></li>
</ul></li>
</ul>
</div>
<h1 id="what-is-make"><a href="#what-is-make">What is Make?</a></h1>
<p>GNU Make is a tool which controls the generation of executables and other non-source files of a program from the program's source files.</p>
<p>Make gets its knowledge of how to build your program from a file called the _Makefile), which lists each of the non-source files and how to compute it from other files. When you write a program, you should write a makefile for it, so that it is possible to use Make to build and install the program.</p>
<h2 id="capabilities-of-make"><a href="#capabilities-of-make">Capabilities of Make</a></h2>
<ul>
<li>Make enables the end user to build and install your package without knowing the details of how that is done -- because these details are recorded in the makefile that you supply.</li>
<li>Make figures out automatically which files it needs to update, based on which source files have changed. It also automatically determines the proper order for updating files, in case one non-source file depends on another non-source file.</li>
<li>As a result, if you change a few source files and then run Make, it does not need to recompile all of your program. It updates only those non-source files that depend directly or indirectly on the source files that you changed.</li>
<li>Make is not limited to any particular language. For each non-source file in the program, the makefile specifies the shell commands to compute it. These shell commands can run a compiler to produce an object file, the linker to produce an executable, ar to update a library, or TeX or Makeinfo to format documentation.</li>
</ul>
<p>GNU make is ubiquitous in the linux world for installing and compiling software. It has been widely used to build computational pipelines because it supports:</p>
<ul>
<li>Stopping and restarting computational processes</li>
<li>Running multiple, even thousands of jobs in parallel</li>
</ul>
<p>For some notes on its drawbacks, and some more recent alternatives see:</p>
<ul>
<li><a href="http://www.ruffus.org.uk/design.html">http://www.ruffus.org.uk/design.html</a>.</li>
<li><a href="http://aegis.sourceforge.net/auug97.pdf">Recursive Make considered harmful</a></li>
</ul>
<h1 id="more-about-make"><a href="#more-about-make">More about MAKE</a></h1>
<p>A domain-specific language for handling dependencies.</p>
<p>MAKE = list of rules:</p>
<pre><code>target: dependents
   script for generating target
   </code></pre>
<p>Internally, Make is a tree of dependancies and if the leaves are newer than the parents, then the parents are regenerated. from the kids.</p>
<p>Example of a <em>Makefile</em> (default is to run the first rule).</p>
<pre><code>SHELL=/bin/bash
CFLAGS=-g -Wall -ansi -pedantic
Exe=$(HOME)/bin
CC=gcc

all: tar3

tar3: $(Exe)/tar3

$(Exe)/tar3 : c/*.c
    cd c &amp;&amp; $(CC)  $(CFLAGS) -o $(Exe)/tar3 *.c -lm
    @echo $(Exe)/tar3</code></pre>
<p>Question: if I call this twice, nothing happens the second time. Why?</p>
<p>Another <em>Makefile</em>. Builds the web site for this subject. Source code comes from <em>doc/<em><em>. Results got to </em>var/</em></em>. In the following:</p>
<ul>
<li><em><span class="math">$@_ is the target and _$</span>&lt;</em> is the first dependent.</li>
<li><em>$(shell ...)</em> calls stuff outside make.</li>
<li><em>$(subset old, new, this)</em> is text substitution.</li>
</ul>
<pre><code>    Down=markdown_py -x footnotes -x tables -x fenced_code -x codehilite
    Mds=$(shell ls doc/*.md)
    Htmls=$(subst .md,.html,$(subst doc/,var/,$(Mds)))
    
    all: dirs sources pythons htmls commit status
    
    # some stuff removed
    
    htmls: $(Htmls)
    
    var/%.html : doc/%.md
        $(Down)  $&lt; &gt; $@
        svn -q add --force $@
        svn -q propset svn:mime-type text/html $@
    
    commit:
        svn commit -m stuff --username $(Who) --password $(Pass)</code></pre>
<p>Question: if I call this twice, nothing happens the second time. Why?</p>
<h2 id="aside-parallel-makes"><a href="#aside-parallel-makes">Aside: Parallel Makes</a></h2>
<ul>
<li>Make can analyze a dependency tree</li>
<li>Identity unrelated branches</li>
<li>Can run one branch per processor.</li>
</ul>
<p>So simple!</p>
<pre><code>make -j 4 # for a quad-core machine</code></pre>
<p>For example:</p>
<pre><code>   prog :  x.o  y.o  z.o
           cc  x.o  y.o  z.o  -lm  -o prog
   x.o  :  x.c  defs.h
           cc  -c  x.c
   y.o  :  y.c  defs.h
           cc  -c  y.c
   z.o  :  z.c
           cc  -c  z.c</code></pre>
<p>For the makefile shown above, it would create processes to build x.o, y.o and z.o in parallel. After these processes were complete, it would build prog.</p>
<p>You can use the .MUTEX directive to serialize the updating of some specified targets. This is useful when two or more targets modify a common output file.<br />To prevent make from building x.o and y.o in parallel, the makefile above would contain a .MUTEX directive of the form:</p>
<pre><code>   .MUTEX: x.o y.o</code></pre>
<h2 id="configuring-make"><a href="#configuring-make">Configuring Make</a></h2>
<p>If we sperate Makefiles into some initial config then sme generic processing, we can do a better job of reusing code.</p>
<p>For example, here is a configuration file that sets some variables:</p>
<pre><code>Out=../../www/cs510
Raw=$(PWD)
Lib=./lib

include $(Lib)/lib.mk</code></pre>
<p>Note that the last line includes another file and that file has many rules. <em>Any</em> of these can be called from the command line using (e.g. <code>make ready</code> or <code>make gitting</code>).</p>
<p>First rule is the default rule</p>
<pre><code>ready : dirs files dots talks plots pages
    @echo &quot;See $(Out)&quot;</code></pre>
<p>Convenience code for stopping GIT pestering your for passwords</p>
<pre><code>gitting:
    git config --global credential.helper cache
    git config credential.helper &#39;cache --timeout=3600&#39;</code></pre>
<p>As a commit hook, as a side effect of saving, we update site</p>
<pre><code>commit: ready save</code></pre>
<p>Convenience functions for git</p>
<pre><code>save:
    - git status
    - git commit -a
    - git push origin master

addll:
    git add --all 

typo:
    - git status
    - git commit -am &quot;typo&quot;
    - git push origin master

update:
    - git pull origin master

status:
    - git status</code></pre>
<p>Setting up dir structure</p>
<pre><code>Skeleton=dot etc plot slides verbatim/img
dirs: 
    @$(foreach d,$(Skeleton),mkdir -p $(Raw)/$d;)
    @mkdir -p $(Out)/slides
    @mkdir -p $(Out)/posts
    @ mkdir -p $(Out)/img/dot
    @ mkdir -p $(Out)/img/plot
    @cp -vrup $(Lib)/etc/* $(Raw) 

files:
    @cp -vrup $(Raw)/verbatim/* $(Out)</code></pre>
<p>Generates lists of files to switch</p>
<pre><code>talks:  $(call target,slides,md,html,$(Raw),$(Out))
dots  : $(call target,dot,dot,png,$(Raw),$(Out)/img)
plots : $(call target,plot,plt,png,$(Raw),$(Out)/img)
pages : $(call target,posts,md,html,$(Raw),$(Out))</code></pre>
<p>Subroutine. changes pathnames and suffixes. called via $(call target,dir,oldExt,newExtension,OldPath,NewPath)</p>
<pre><code>define target
   $(subst $4,$5,\
      $(subst .$2,.$3,\
         $(shell ls $(Raw)/$1/*.$2)))
endef</code></pre>
<p>Debugging trick</p>
<pre><code>debug:
    echo  $(call target,posts,md,html,$(Raw),$(Out))</code></pre>
<p>Finally, the workers</p>
<p>Making slides:</p>
<pre><code>$(Out)/slides/%.html : $(Raw)/slides/%.md 
    pandoc -s \
              --webtex -i -t slidy \
              -r markdown+simple_tables+table_captions \
              --biblio $(Raw)/biblio.bib \
          -c        ../img/slidy.css \
              -o $@ $&lt;</code></pre>
<p>Making directed graphs.</p>
<pre><code>$(Out)/img/dot/%.png : $(Raw)/dot/%.dot
    dot -Tpng -o $@ $&lt;</code></pre>
<p>Visualizing data</p>
<pre><code>$(Out)/img/plot/%.png : $(Raw)/plot/%.plt
    gnuplot $&lt; &gt; $@</code></pre>
<p>Making good old fashioned html pages.</p>
<pre><code>$(Out)/posts/%.html : $(Raw)/posts/%.md
    pandoc -s \
              -r markdown+simple_tables+table_captions+pipe_tables \
        -B $(Raw)/before.html \
              --biblio $(Raw)/biblio.bib \
                -c        ../img/posty.css \
              -o $@ $&lt;</code></pre>
<p>That's all folks.</p>
<div class="references">

</div>
</body>
</html>
